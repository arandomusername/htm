import cla

inhibition_radius = 5 # shouldn't be 0
min_overlap       = 3 # starts with 0



def get_overlap_onedim(Input,region):
	overlap_list = []

	for coll in region.colloumns:
		overlap = 0
		for dendrit in coll.dendrit_segment:
			
			#Umwandeln von den "2-dimensionalen"-Dendriten auf den eindimensionalen Input		
			position = (coll.dendrit_segment.max_groesse - 1 ) ** dendrit[0] + dendrit[1]

			if dendrit.uebertraegt_signal(Input[position]):
				overlap = overlap + 1

		coll.overlap = overlap

def check_inhibition(region):
	winner = []

	for coll in region.colloumns:
		nachbarliste 	 = region.nachbaren(coll.position,inhibition_radius)
		minlocalactivity = n_kleinste_ueberlappung(nachbarliste,region)
		
		if coll.overlap > 0 and coll.overlap >= minlocalactivity:
			winner.append(coll.position)

	return winner

def learning(winners,region):
	for pos in winners:
		coll = coll_by_position(pos)

		for dendrit in coll.dendrit_segment:
			if dendrit.aktiv:
				dendrit.permanenz_erhoehen()
			else:
				dendrit.permanenz_senken()

	
def n_kleinste_ueberlappung(nachbarliste,region):
	overlap_measures = []

	for position in nachbarliste:
		coll  = region.coll_by_position(position)
		overlap_measures.append(coll.overlap)
	
	overlap_measures.sort(key=int)
	return overlapt_measures[min_overlap]
	

